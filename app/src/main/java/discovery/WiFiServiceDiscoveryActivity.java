
package discovery;

import android.app.Activity;
import android.app.Fragment;
import android.app.PendingIntent;
import android.content.BroadcastReceiver;
import android.content.ContentValues;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.IntentSender;
import android.database.Cursor;
import android.database.sqlite.SQLiteDatabase;
import android.location.Location;
import android.net.Uri;
import android.net.wifi.WpsInfo;
import android.net.wifi.p2p.WifiP2pConfig;
import android.net.wifi.p2p.WifiP2pDevice;
import android.net.wifi.p2p.WifiP2pInfo;
import android.net.wifi.p2p.WifiP2pManager;
import android.net.wifi.p2p.WifiP2pManager.ActionListener;
import android.net.wifi.p2p.WifiP2pManager.Channel;
import android.net.wifi.p2p.WifiP2pManager.ConnectionInfoListener;
import android.net.wifi.p2p.WifiP2pManager.DnsSdServiceResponseListener;
import android.net.wifi.p2p.WifiP2pManager.DnsSdTxtRecordListener;
import android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceInfo;
import android.net.wifi.p2p.nsd.WifiP2pDnsSdServiceRequest;
import android.os.BatteryManager;
import android.os.Build;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.os.Message;
import android.support.annotation.RequiresApi;
import android.util.Log;
import android.view.View;
import android.widget.TextView;
import android.widget.Toast;

import com.google.android.gms.appindexing.Action;
import com.google.android.gms.appindexing.AppIndex;
import com.google.android.gms.common.ConnectionResult;
import com.google.android.gms.common.GooglePlayServicesUtil;
import com.google.android.gms.common.api.GoogleApiClient;
import com.google.android.gms.common.api.GoogleApiClient.ConnectionCallbacks;
import com.google.android.gms.common.api.GoogleApiClient.OnConnectionFailedListener;
import com.google.android.gms.location.Geofence;
import com.google.android.gms.location.LocationListener;
import com.google.android.gms.location.LocationRequest;
import com.google.android.gms.location.LocationServices;

import org.json.JSONArray;
import org.json.JSONObject;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.StringTokenizer;
import java.util.UUID;

import discovery.WiFiChatFragment.MessageTarget;
import discovery.WiFiDirectServicesList.DeviceClickListener;
import discovery.WiFiDirectServicesList.WiFiDevicesAdapter;
import discovery.database.MessageBaseHelper;
import discovery.database.MessageCursorWrapper;
import discovery.database.MessageDbSchema;
import discovery.geofencing.GeofenceTransitionsIntentService;
import discovery.geofencing.SimpleGeofence;
import discovery.geofencing.SimpleGeofenceStore;

import static discovery.Constants.ANDROID_BUILDING_ID;
import static discovery.Constants.ANDROID_BUILDING_LATITUDE;
import static discovery.Constants.ANDROID_BUILDING_LONGITUDE;
import static discovery.Constants.ANDROID_BUILDING_RADIUS_METERS;
import static discovery.Constants.CONNECTION_FAILURE_RESOLUTION_REQUEST;
import static discovery.Constants.GEOFENCE_EXPIRATION_TIME;

/**
 * The main activity for the sample. This activity registers a local service and
 * perform discovery over Wi-Fi p2p network. It also hosts a couple of fragments
 * to manage chat operations. When the app is launched, the device publishes a
 * chat service and also tries to discover services published by other peers. On
 * selecting a peer published service, the app initiates a Wi-Fi P2P (Direct)
 * connection with the peer. On successful connection with a peer advertising
 * the same service, the app opens up sockets to initiate a chat.
 * {@code WiFiChatFragment} is then added to the the main activity which manages
 * the interface and messaging needs for a chat session.
 */
public class WiFiServiceDiscoveryActivity extends Activity implements
        DeviceClickListener, Handler.Callback, MessageTarget, ConnectionInfoListener, ConnectionCallbacks, OnConnectionFailedListener, LocationListener {

    public static final String TAG = "wifidirectdemo";

    // TXT RECORD properties
    public static final String TXTRECORD_PROP_AVAILABLE = "available";
    public static final String SERVICE_INSTANCE = "_wifidemotest";
    public static final String SERVICE_REG_TYPE = "_presence._tcp";
    public static final String AUTOGENERATED = "Good Morning Everyone!";
    public static final String AUTOGENERATED2 = "This is a message every 10 min";


    public static final int MESSAGE_READ = 0x400 + 1;
    public static final int MY_HANDLE = 0x400 + 2;
    private WifiP2pManager manager;

    static final int SERVER_PORT = 4545;

    private final IntentFilter intentFilter = new IntentFilter();
    private final IntentFilter intentFilterGeo = new IntentFilter();


    private Channel channel;
    private BroadcastReceiver receiver = null;
    private WifiP2pDnsSdServiceRequest serviceRequest;

    private Handler handler = new Handler(this);
    private WiFiChatFragment chatFragment;
    private WiFiDirectServicesList servicesList;
    private TextView statusTxtView;

    private static SQLiteDatabase mDatabase; // for db
    private Context mContext; // for db

    private static WifiP2pDevice myDevice;

    public static WiFiServiceDiscoveryActivity instace;

    private JSONArray mMessageArray = new JSONArray();        // limit to the latest 50 messages
    private static int fileNumber;
    private ArrayList<Scan> scans = new ArrayList();
    private ArrayList<Connection> connections = new ArrayList();
    private SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss.SSS");
    private int level;
    private Scan scan;
    private Connection currentCon;
    private List<WifiP2pDevice> mPeers = new ArrayList<WifiP2pDevice>();  // update on every peers available

    private WifiP2pDevice peer;
    private boolean in = true;
    private boolean sendDB = false;
    private boolean received = false;
    private String superString = "";
    private boolean firstTime = true;
    private int loopSec = 1000;
    private int lastVisit = 1000;
    private int scanTimeout = 15000;
    private int connectingTimeout = 10000;
    private int connectedTimeout = 4000;
    private int disconnectingTimeout = 10000;


    // geofencing ///////////////////////////////////////////////////////////////////////////////////////////////

    private static boolean del = false;
    // Internal List of Geofence objects. In a real app, these might be provided by an API based on
    // locations within the user's proximity.
    private List<Geofence> mGeofenceList;

    // These will store hard-coded geofences in this sample app.
    private SimpleGeofence mAndroidBuildingGeofence;

    // Persistent storage for geofences.
    private SimpleGeofenceStore mGeofenceStorage;

    private LocationServices mLocationService;
    // Stores the PendingIntent used to request geofence monitoring.
    private PendingIntent mGeofenceRequestIntent;
    private GoogleApiClient mApiClient;

    private Location mLastLocation;
    private String mLastUpdateTime;

    private String mLatitudeText;
    private String mLongitudeText;
    private LocationRequest mLocationRequest;
    private boolean idle = false;
    private double randomno;

    /**
     * ATTENTION: This was auto-generated to implement the App Indexing API.
     * See https://g.co/AppIndexing/AndroidStudio for more information.
     */
    private GoogleApiClient client;

    private HashMap<String, Long> connectionMap = new HashMap<>();

    public static void setDel(boolean del) {
        WiFiServiceDiscoveryActivity.del = del;
    }

    public static boolean isDel() {
        return del;
    }

    public int getLoopSec() {
        return loopSec;
    }

    public void setLoopSec(int loopSec) {
        this.loopSec = loopSec;
    }

    public Handler getHandler() {
        return handler;
    }

    public void setHandler(Handler handler) {
        this.handler = handler;
    }

    public boolean isIdle() {
        return idle;
    }

    /**
     * Called when the activity is first created.
     */
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.main);
        statusTxtView = (TextView) findViewById(R.id.status_text);

        //Thread.setDefaultUncaughtExceptionHandler(new DefaultExceptionHandler(this));
        instace = this;

        intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION);
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION);
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION);
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION);

        intentFilterGeo.addAction(String.valueOf(Geofence.GEOFENCE_TRANSITION_ENTER));
        intentFilterGeo.addAction(String.valueOf(Geofence.GEOFENCE_TRANSITION_EXIT));


        manager = (WifiP2pManager) getSystemService(Context.WIFI_P2P_SERVICE);
        channel = manager.initialize(this, getMainLooper(), null);

        servicesList = new WiFiDirectServicesList();
        getFragmentManager().beginTransaction().add(R.id.container_root, servicesList, "services").commit();
        startRegistrationAndDiscovery();


        mContext = getApplicationContext(); // for db
//        mDatabase.execSQL("delete from "+ MessageDbSchema.MessageTable.NAME);
//        mDatabase.execSQL("delete from "+ MessageDbSchema.ConnectionTable.NAME);
//        mDatabase.execSQL("delete from "+ MessageDbSchema.ScanTable.NAME);
        //  mContext.deleteDatabase("messageBase.db");

        mDatabase = new MessageBaseHelper(mContext).getWritableDatabase();// for db
        Log.d(TAG, "CREANDO DTBBBBBBBBBB");

//        if(!MessageDbSchema.InfoTable.NAME.isEmpty()){
//            info = getInfoDB();
//        }

        ////////////// Event every minute to upload the logs /////////
        final Handler h = new Handler();
        int delay = 60000; //milliseconds

        h.postDelayed(new Runnable() {
            public void run() {

                Log.d(TAG, "ADDING INFO EVERY MINUTE");

                //if(getCurrentCon() == null){

//                    WifiManager wifiManager = (WifiManager)getApplicationContext().getSystemService(Context.WIFI_SERVICE);
//                    wifiManager.setWifiEnabled(true);

                createServerInfoFile();

//                    new AsyncTask<Integer, Void, Void>() {
//                        @Override
//                        protected Void doInBackground(Integer... params) {
//                            try {
//
//                                String sub = getMyDevice().deviceName.substring(getMyDevice().deviceName.lastIndexOf('_') + 1);
//
//                                SCPTest scpTest = new SCPTest();
//                                scpTest.SCPTestMain(sub);
//                            } catch (Exception e) {
//                                e.printStackTrace();
//                            }
//                            return null;
//                        }
//
//                    }.execute();

                h.postDelayed(this, 60000);

                //}
            }
        }, delay);


        ////////////// Event every 1 sec connect to new device /////////
        final Handler h2 = new Handler();
        int delay2 = loopSec; //milliseconds

        h2.postDelayed(new Runnable() {
            public void run() {

                if (myDevice != null)
                    updateThisDevice(myDevice);

                // check if the device has left the geofence
                if (isDel()) {
                    removeAllMessages();
                    setDel(false);
                }

                if(isIdle())
                    Log.d(TAG, "IDLE... " + (getScan()==null));
                Log.d(TAG, "Services: " + servicesList.listAdapter.getItems().size());

                if (getCurrentCon() == null) {
                    if (getScan() != null) {
                        if (servicesList.listAdapter.getItems().size() > 0) {
                            if ((getScan().getScanIni() + scanTimeout) > System.currentTimeMillis()) {
                                Log.d(TAG, "Scan not null and list with peers --> PROCESS");
                                process(); // peer list should not be empty
                            } else {
                                Log.d(TAG, "Scan not null, list with peers, longer than 4 seconds");
                                // kill scan
                                getScan().setScanEnd(System.currentTimeMillis());
                                ArrayList<String> peersList = new ArrayList();
                                for (WiFiP2pService peer : getServicesList().listAdapter.getItems()) {
                                    String sub = peer.device.deviceName.substring(peer.device.deviceName.lastIndexOf('_') + 1);
                                    peersList.add(sub);
                                }
                                getScan().setPeers(peersList);
                                PTPLog.d(TAG, "PEERS:  " + getScan().getPeers());
                                getScan().setScanDur();
                                PTPLog.d(TAG, "STORING:  " + "ID- " + getScan().getId());
                                getScans().add(scan);
                                addScan(scan); //DATABASE

                                PTPLog.d(TAG, "SCAN INI: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanIni()) + "\n" +
                                        "SCAN END: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanEnd()) + "\n" +
                                        "SCAN DUR: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanDur()));

                                setScan(null);
                                discoverService();
                            }
                        } else {
                            if((getScan().getScanIni() + scanTimeout) > System.currentTimeMillis()){
                                Log.d(TAG, "Scan not null and list without peers, still on time");
                            }
                            else {
                                Log.d(TAG, "Scan not null, list without peers, expired");
                                // kill scan
                                getScan().setScanEnd(System.currentTimeMillis());
                                ArrayList<String> peersList = new ArrayList();
                                for (WiFiP2pService peer : getServicesList().listAdapter.getItems()) {
                                    String sub = peer.device.deviceName.substring(peer.device.deviceName.lastIndexOf('_') + 1);
                                    peersList.add(sub);
                                }
                                getScan().setPeers(peersList);
                                PTPLog.d(TAG, "PEERS:  " + getScan().getPeers());
                                getScan().setScanDur();
                                PTPLog.d(TAG, "STORING:  " + "ID- " + getScan().getId());
                                getScans().add(scan);
                                addScan(scan); //DATABASE

                                PTPLog.d(TAG, "SCAN INI: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanIni()) + "\n" +
                                        "SCAN END: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanEnd()) + "\n" +
                                        "SCAN DUR: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanDur()));

                                setScan(null);
                                discoverService();

                            }
                        }
                    } else if (getScan() == null) {
                        Log.d(TAG, "Scan null");
                        if(!isIdle())
                            discoverService(); // if not connection, not scan and not idle...start scan?
                        else
                            Log.d(TAG, "Scan null and Idle");

                    }

                }else if (getCurrentCon() != null) {
                    Log.d(TAG, "CONNECTION NOT NULL");


                    if (isSendDB() && isReceived()) {
                        if((getCurrentCon().getDisconnecting() == 0)) {
                            Log.d(TAG, "CONNECTION SUCCEEDED");
                            Log.d(TAG, "DISCONNECTING");
                            getCurrentCon().setDisconnecting(System.currentTimeMillis());
                            disconnect();
                            discoverService();
                        }
                        else if (getCurrentCon().getDisconnecting() != 0) {
                            if((getCurrentCon().getDisconnecting() + disconnectingTimeout) < System.currentTimeMillis()){
                                Log.d(TAG, "DISCONNECTING LONGER THAN 10 SECONDS");

                                // This code is done in disconnect(), but in this case disconnect() is not responding
                                getCurrentCon().setConEnd(System.currentTimeMillis());
                                PTPLog.d(TAG, "CON END: " + sdf.format(new Date(getCurrentCon().getConEnd())));
                                getConnections().add(getCurrentCon());
                                addConnection(getCurrentCon()); //DATABASE
                                setSendDB(false);
                                setReceived(false);
                                setCurrentCon(null);
                                getFragmentManager().beginTransaction().replace(R.id.container_root, getServicesList(), "services").commit();
                                getStatusTxtView().setText("");
                                getStatusTxtView().setVisibility(View.VISIBLE);
                                discoverService();
                            }else{
                                Log.d(TAG, "Still disconnecting, no longer than 4 seconds");
                            }
                        }
                    }else if(!(isSendDB() && isReceived())){
                        if(getCurrentCon().getConIni() != 0) {
                            if((getCurrentCon().getConIni() + connectedTimeout) < System.currentTimeMillis()){
                                Log.d(TAG, "CONNECTION LONGER THAN 4 SECONDS: " + isSendDB() + "-" + isReceived() + "-" + ((getCurrentCon().getConIni() + connectedTimeout) < System.currentTimeMillis()));

                                getCurrentCon().setFailure(System.currentTimeMillis());

                                getCurrentCon().setFailed(true);
                                Log.d(TAG, "TIMEOUT FAILURE: " + new Date(getCurrentCon().getFailure()));
                                disconnect();
                                discoverService();
                            } else{
                                Log.d(TAG, "Connection NOT longer than 4 seconds yet");
                            }
                        }else{
                            Log.d(TAG, "Connection does not have conIni, connection has not been established yet.");
                            if(getCurrentCon().getConnecting() != 0){
                                if((getCurrentCon().getConnecting() + connectingTimeout) < System.currentTimeMillis()){
                                    Log.d(TAG, "CONNECTING LONGER THAN 10 SECONDS: " + isSendDB() + "-" + isReceived() + "-" + ((getCurrentCon().getConnecting() + connectingTimeout) < System.currentTimeMillis()));

                                    getCurrentCon().setFailure(System.currentTimeMillis());
                                    getCurrentCon().setFailed(true);

                                    Log.d(TAG, "TIMEOUT FAILURE: " + new Date(getCurrentCon().getFailure()));
                                    disconnect();
                                    discoverService();
                                } else{
                                    Log.d(TAG, "Connecting no longer than 4 seconds yet.");
                                }
                            } else {
                                Log.d(TAG, "Connection does not have conIni, neither connecting time."); // This should not happend.
                            }
                        }
                    }


                }
                h2.postDelayed(this, loopSec);
            }
        }, delay2);


        ////////////// Event every 10 min to generate a new message and log battery info /////////
        final Handler h3 = new Handler();
        int delay3 = 600000; //milliseconds

        h3.postDelayed(new Runnable() {
            public void run() {

                Date now = new Date();
                String time = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(now);
                String myName = getMyDevice().deviceName;

                String sub = myName.substring(myName.lastIndexOf('_') + 1);

                MessageRow messageRow = new MessageRow(UUID.randomUUID(), myName, AUTOGENERATED2, null, null, sub + "-at-" + time);

                String jsonMsg = shiftInsertMessage(messageRow);
                PTPLog.d(TAG, "Json autoGenerated: " + jsonMsg);
                addMessage(messageRow); // for db

                Intent batteryIntent = registerReceiver(null, new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
                int currentLevel = batteryIntent.getIntExtra(BatteryManager.EXTRA_LEVEL, 0);
                level = currentLevel;
                BatteryEvent batEvent = new BatteryEvent(level, sdf.format(System.currentTimeMillis()));
                addBatteryEvent(batEvent); //DATABASE
                PTPLog.d(TAG, "BATTERRRRYYYY " + batEvent.getPercentage() + batEvent.getTime());
//                if (currentLevel != level) {
//                    level = currentLevel;
//                    BatteryEvent batEvent = new BatteryEvent(level,sdf.format(System.currentTimeMillis()));
//                    addBatteryEvent(batEvent); //DATABASE
//                    PTPLog.d(TAG, "BATTERRRRYYYY " + batEvent.getPercentage() + batEvent.getTime());
//
//                }

                h3.postDelayed(this, 600000);
            }
        }, delay3);


        ///////////////////////////////////////////////////////////////////////////////////
        // ATTENTION: This was auto-generated to implement the App Indexing API.
        // See https://g.co/AppIndexing/AndroidStudio for more information.
        client = new GoogleApiClient.Builder(this).addApi(AppIndex.API).build();


        if (!isGooglePlayServicesAvailable()) {
            Log.e(TAG, "Google Play services unavailable.");
            //finish();
            return;
        }

        mApiClient = new GoogleApiClient.Builder(this)
                .addApi(LocationServices.API)
                .addConnectionCallbacks(this)
                .addOnConnectionFailedListener(this)
                .build();

        createLocationRequest();

        // Instantiate a new geofence storage area.
        mGeofenceStorage = new SimpleGeofenceStore(this);
        // Instantiate the current List of geofences.
        mGeofenceList = new ArrayList<Geofence>();
        createGeofences();
    }


    @Override
    public Context getApplicationContext() {
        return super.getApplicationContext();
    }

    public static WiFiServiceDiscoveryActivity getInstance() {
        return instace;
    }

    ////////////////////////////////////////////////// Geofencing Methods //////////////////////////////////


    @Override
    public void onConnected(Bundle bundle) {
        // Get the PendingIntent for the geofence monitoring request.
        // Send a request to add the current geofences.
        mGeofenceRequestIntent = getGeofenceTransitionPendingIntent();
        LocationServices.GeofencingApi.addGeofences(mApiClient, mGeofenceList, mGeofenceRequestIntent);
        Log.d(TAG, "GEOFENCES--> : " + mGeofenceList);

        Toast.makeText(this, getString(R.string.start_geofence_service), Toast.LENGTH_SHORT).show();

        mLastLocation = LocationServices.FusedLocationApi.getLastLocation(
                mApiClient);
        if (mLastLocation != null) {
            mLatitudeText = String.valueOf(mLastLocation.getLatitude());
            mLongitudeText = String.valueOf(mLastLocation.getLongitude());
        }

        Log.d(TAG, "LOCATION--> : " + mLatitudeText + mLongitudeText);
        //Log.e(TAG, "CONNECTED API CLIENT GOOGLE --> " + mApiClient + " " + mApiClient.isConnected());
        startLocationUpdates();

    }

    protected void startLocationUpdates() {
        LocationServices.FusedLocationApi.requestLocationUpdates(mApiClient, mLocationRequest, this);
    }

    @Override
    public void onLocationChanged(Location location) {
        mLastLocation = location;
        mLastUpdateTime = DateFormat.getTimeInstance().format(new Date());
        //PTPLog.d(TAG, "LOCATION CHANGED " + location);

        //Toast.makeText(this, getString(R.string.location_changed) + " - " + mLastLocation.getLatitude() + " - " + mLastLocation.getLongitude(), Toast.LENGTH_SHORT).show();

    }


    @Override
    public void onConnectionSuspended(int i) {
        if (null != mGeofenceRequestIntent) {
            LocationServices.GeofencingApi.removeGeofences(mApiClient, mGeofenceRequestIntent);
        }
    }

    @Override
    public void onConnectionFailed(ConnectionResult connectionResult) {
        // If the error has a resolution, start a Google Play services activity to resolve it.
        if (connectionResult.hasResolution()) {
            try {
                connectionResult.startResolutionForResult(this,
                        CONNECTION_FAILURE_RESOLUTION_REQUEST);
            } catch (IntentSender.SendIntentException e) {
                Log.e(TAG, "Exception while resolving connection error.", e);
            }
        } else {
            int errorCode = connectionResult.getErrorCode();
            Log.e(TAG, "Connection to Google Play services failed with error code " + errorCode);
        }
    }

    protected void createLocationRequest() {
        mLocationRequest = new LocationRequest();
        mLocationRequest.setInterval(10000);
        mLocationRequest.setFastestInterval(5000);
        mLocationRequest.setPriority(LocationRequest.PRIORITY_HIGH_ACCURACY);
        Log.e(TAG, "LOCATION REQUEST --> " + mLocationRequest);

    }


    /**
     * In this sample, the geofences are predetermined and are hard-coded here. A real app might
     * dynamically create geofences based on the user's location.
     */
    public void createGeofences() {
        // Create internal "flattened" objects containing the geofence data.
        mAndroidBuildingGeofence = new SimpleGeofence(
                ANDROID_BUILDING_ID,                // geofenceId.
                ANDROID_BUILDING_LATITUDE,
                ANDROID_BUILDING_LONGITUDE,
                ANDROID_BUILDING_RADIUS_METERS,
                GEOFENCE_EXPIRATION_TIME,
                Geofence.GEOFENCE_TRANSITION_ENTER | Geofence.GEOFENCE_TRANSITION_EXIT
        );

        // Store these flat versions in SharedPreferences and add them to the geofence list.
        mGeofenceStorage.setGeofence(ANDROID_BUILDING_ID, mAndroidBuildingGeofence);
        mGeofenceList.add(mAndroidBuildingGeofence.toGeofence());
    }

    /**
     * Checks if Google Play services is available.
     *
     * @return true if it is.
     */
    private boolean isGooglePlayServicesAvailable() {
        int resultCode = GooglePlayServicesUtil.isGooglePlayServicesAvailable(this);

        if (ConnectionResult.SUCCESS == resultCode) {
            if (Log.isLoggable(TAG, Log.DEBUG)) {
                Log.d(TAG, "Google Play services is available.");
            }
            return true;
        } else {
            Log.e(TAG, "Google Play services is unavailable.");
            return false;
        }
    }


    /**
     * Create a PendingIntent that triggers GeofenceTransitionIntentService when a geofence
     * transition occurs.
     */
    private PendingIntent getGeofenceTransitionPendingIntent() {
        Intent intent = new Intent(this, GeofenceTransitionsIntentService.class);
        return PendingIntent.getService(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);
    }
    ////////////////////////////////////////////////////////////////////////////////////////////////


    public HashMap<String, Long> getConnectionMap() {
        return connectionMap;
    }

    public Channel getChannel() {
        return channel;
    }

    public List<WifiP2pDevice> getmPeers() {
        return mPeers;
    }

    public WifiP2pManager getManager() {
        return manager;
    }

    @Override
    protected void onRestart() {
        Fragment frag = getFragmentManager().findFragmentByTag("services");
        if (frag != null) {
            getFragmentManager().beginTransaction().remove(frag).commit();
        }
        super.onRestart();

    }

    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);

        if (!hasFocus) {
            Intent closeDialog = new Intent(Intent.ACTION_CLOSE_SYSTEM_DIALOGS);
            sendBroadcast(closeDialog);
        }
    }

    @Override
    protected void onStop() {

        // ATTENTION: This was auto-generated to implement the App Indexing API.
        // See https://g.co/AppIndexing/AndroidStudio for more information.
        Action viewAction = Action.newAction(
                Action.TYPE_VIEW, // TODO: choose an action type.
                "WiFiServiceDiscovery Page", // TODO: Define a title for the content shown.
                // TODO: If you have web page content that matches this app activity's content,
                // make sure this auto-generated web page URL is correct.
                // Otherwise, set the URL to null.
                Uri.parse("http://host/path"),
                // TODO: Make sure this auto-generated app URL is correct.
                Uri.parse("android-app://com.example.android.wifidirect.discovery/http/host/path")
        );
        super.onStop();

        AppIndex.AppIndexApi.end(client, viewAction);
        // ATTENTION: This was auto-generated to implement the App Indexing API.
        // See https://g.co/AppIndexing/AndroidStudio for more information.
        client.disconnect();
        mApiClient.disconnect();
    }

    /**
     * Registers a local service and then initiates a service discovery
     */
    private void startRegistrationAndDiscovery() {

        statusTxtView.setText("");
        statusTxtView.setVisibility(View.VISIBLE);

        //  Create a string map containing information about your service.

        Map<String, String> record = new HashMap<String, String>();
        record.put(TXTRECORD_PROP_AVAILABLE, "visible");


        // Service information.  Pass it an instance name, service type
        // _protocol._transportlayer , and the map containing
        // information other devices will want once they connect to this one.
        WifiP2pDnsSdServiceInfo service = WifiP2pDnsSdServiceInfo.newInstance(SERVICE_INSTANCE, SERVICE_REG_TYPE, record);


        // Add the local service, sending the service info, network channel,
        // and listener that will be used to indicate success or failure of
        // the request.


        manager.addLocalService(channel, service, new ActionListener() {

            @Override
            public void onSuccess() {
                appendStatus("Added Local Service");
            }

            @Override
            public void onFailure(int error) {
                appendStatus("Failed to add a service");
            }
        });

        discoverService();
    }

    public void discoverService() {

        /*
         * Register listeners for DNS-SD services. These are callbacks invoked
         * by the system when a service is actually discovered.
         */

        /// check there is no scan active
        if (getScan() == null) {

            getStatusTxtView().setText("");
            idle = true;

            Log.d(TAG, "IDLE -----> " + isIdle());

            final Handler hndl = new Handler();
            int delay = 0; //milliseconds

            hndl.postDelayed(new Runnable() {
                public void run() {

                    Scan scan = new Scan(System.currentTimeMillis());
                    setScan(scan);
                    Log.d(TAG, "SCAN INI --> " + "ID- " + scan.getId() + " - " + sdf.format(new Date(getScan().getScanIni())) + "-" + getScan().getId());

                    manager.setDnsSdResponseListeners(channel,
                            new DnsSdServiceResponseListener() {


                                @Override
                                public void onDnsSdServiceAvailable(String instanceName,
                                                                    String registrationType, WifiP2pDevice srcDevice) {

                                    // A service has been discovered. Is this our app?

                                    if (instanceName.equalsIgnoreCase(SERVICE_INSTANCE)) {

                                        // update the UI and add the item the discovered device.
                                        WiFiDirectServicesList fragment = (WiFiDirectServicesList) getFragmentManager().findFragmentByTag("services");

                                        if (fragment != null) {
                                            WiFiDevicesAdapter adapter = ((WiFiDevicesAdapter) fragment.getListAdapter());

                                            WiFiP2pService service = new WiFiP2pService();
                                            service.device = srcDevice;
                                            service.instanceName = instanceName;
                                            service.serviceRegistrationType = registrationType;

                                            in = true;
                                            if (!adapter.getItems().isEmpty()) {
                                                for (WiFiP2pService s : adapter.getItems()) {
                                                    Log.d(TAG, "NOMBRES --> " + s.device.deviceName + " " + service.device.deviceName + " " + (s.device.deviceName.equals(service.device.deviceName)));
                                                    if (s.device.deviceName.equals(service.device.deviceName)) {
                                                        in = false;
                                                        Log.d(TAG, "in --> " + in);

                                                    }
                                                }
                                                Log.d(TAG, "in --> " + in);

                                                if (in == true) {
                                                    adapter.add(service);
                                                    Log.d(TAG, "AÑADIENDO2--> " + adapter.getItems().size());
                                                    in = true;
                                                }
                                            } else {
                                                adapter.add(service);
                                                Log.d(TAG, "AÑADIENDO1--> " + adapter.getItems().size());
                                            }

                                            adapter.notifyDataSetChanged();

                                            Log.d(TAG, "onBonjourServiceAvailable "
                                                    + instanceName);

                                        }
                                    }

                                }
                            }, new DnsSdTxtRecordListener() {

                                /**
                                 * A new TXT record is available. Pick up the advertised
                                 * buddy name.
                                 */
                                @Override
                                public void onDnsSdTxtRecordAvailable(
                                        String fullDomainName, Map<String, String> record,
                                        WifiP2pDevice device) {
                                    Log.d(TAG, device.deviceName + " is " + record.get(TXTRECORD_PROP_AVAILABLE) + " - " + device.status);

                                }
                            });

                    // After attaching listeners, create a service request and initiate
                    // discovery.

                    manager.clearServiceRequests(channel,
                            new ActionListener() {

                                @Override
                                public void onSuccess() {
                                    appendStatus("Clear service discovery request");

                                }

                                @Override
                                public void onFailure(int arg0) {
                                    appendStatus("Failed clearing service discovery request");
                                }
                            });

                    serviceRequest = WifiP2pDnsSdServiceRequest.newInstance();
                    manager.addServiceRequest(channel, serviceRequest,
                            new ActionListener() {

                                @Override
                                public void onSuccess() {
                                    appendStatus("Added service discovery request");

                                }

                                @Override
                                public void onFailure(int arg0) {
                                    appendStatus("Failed adding service discovery request");
                                }
                            });


                    manager.discoverServices(channel, new ActionListener() {

                        @Override
                        public void onSuccess() {
                            appendStatus("Service discovery initiated");
                        }

                        @Override
                        public void onFailure(int arg0) {
                            appendStatus("Service discovery failed");

                        }
                    });
                    idle = false;
                    Log.d(TAG, "IDLE -----> " + isIdle());

                }
            }, delay);

        }
    }

    public void process() {

        Log.d(TAG, "Services: " + servicesList.listAdapter.getItems().size() +"--"+ servicesList.listAdapter.getItems().isEmpty() +"--"+ ( (getScan().getScanIni() + scanTimeout) > System.currentTimeMillis()));

        ///////////////////////// loop to make process automatic //////////////////////////////////
        if (!servicesList.listAdapter.getItems().isEmpty() && (getScan().getScanIni() + scanTimeout) > System.currentTimeMillis()) {
            Random rn = new Random();
            //int randomDevice = rn.nextInt((servicesList.listAdapter.getItems().size()-1) - 0 + 1) + 0;
            int randomDevice = rn.nextInt((servicesList.listAdapter.getItems().size()));
            Log.d(TAG, "RANDOM ---> " + servicesList.listAdapter.getItems().size() + " - " + randomDevice);


            WiFiP2pService service = servicesList.listAdapter.getItem(randomDevice);
            //if(!connectionMap.containsKey(service.device.deviceName) || connectionMap.get(service.device.deviceName) + 3600000 > System.currentTimeMillis() ) {
            Log.d(TAG, "RANDOM ---> " + (randomDevice != lastVisit) + "- " + lastVisit);


            if (randomDevice != lastVisit || servicesList.listAdapter.getItems().size() == 1) {
                //CLOSE SCAN
                getScan().setScanEnd(System.currentTimeMillis());
                ArrayList<String> peersList = new ArrayList();
                for (WiFiP2pService peer : getServicesList().listAdapter.getItems()) {
                    String sub = peer.device.deviceName.substring(peer.device.deviceName.lastIndexOf('_') + 1);
                    peersList.add(sub);
                }
                getScan().setPeers(peersList);
                PTPLog.d(TAG, "PEERS:  " + getScan().getPeers());
                getScan().setScanDur();
                PTPLog.d(TAG, "GUARDANDO:  " + "ID- " + getScan().getId());
                getScans().add(scan);
                addScan(scan); //DATABASE

                PTPLog.d(TAG, "SCAN INI: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanIni()) + "\n" +
                        "SCAN END: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanEnd()) + "\n" +
                        "SCAN DUR: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanDur()));

                setScan(null);
                ///////////////////////////////////////////////

                Log.d(TAG, "CONNECTING TO ---> Service information: " + randomDevice + " - " + servicesList.listAdapter.getItem(randomDevice).device.deviceName + " " + servicesList.listAdapter.getItem(randomDevice).device.status);
                //Log.d(TAG, "TOTAL ATTEMPTS ---> " + info.getConnectionsAttempt());
                lastVisit = randomDevice;

                ////////////////////// when p2p connected and this device has started the connection,
                /// create a connection to be added to the list //////
                ///
                if (getScan() != null && (getScan().getScanIni() + scanTimeout) < System.currentTimeMillis()) {
                    getScan().setScanEnd(System.currentTimeMillis());

                    peersList = new ArrayList();
                    for (WiFiP2pService peer : getServicesList().listAdapter.getItems()) {
                        String sub = "";
                        if (peer.device.deviceName.substring(peer.device.deviceName.lastIndexOf('_') + 1) != "") {
                            sub = peer.device.deviceName.substring(peer.device.deviceName.lastIndexOf('_') + 1);
                        }
                        peersList.add(sub);
                    }
                    getScan().setPeers(peersList);
                    PTPLog.d(TAG, "PEERS:  " + getScan().getPeers());

                    getScan().setScanDur();
                    PTPLog.d(TAG, "STORING:  " + "ID- " + getScan().getId());
                    getScans().add(scan);
                    addScan(scan); //DATABASE

                    PTPLog.d(TAG, "SCAN INI: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanIni()) + "\n" +
                            "SCAN END: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanEnd()) + "\n" +
                            "SCAN DUR: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanDur()));

                    setScan(null);

                }

                if (getCurrentCon() == null) {
                    setCurrentCon(new Connection(true));
                    getCurrentCon().setConnecting(System.currentTimeMillis());
                    getCurrentCon().setConnectedPeer(service.device.deviceName);
                    //getConnections().add(getCurrentCon());

                    PTPLog.d(TAG, "CONNECTING TIME:  " + sdf.format(getCurrentCon().getConnecting()));
                    PTPLog.d(TAG, "CONNECTING TO:  " + service.device.deviceName);

                    // introduce a probability to connect to a peer
                    randomno = Math.random();
                    PTPLog.d(TAG, "PROBABILITY TO CONNECT:  " + randomno);

                    if(randomno > 0.5)
                        connectP2p(service);
                }
            } else if (randomDevice == lastVisit) {
                // remove lastVisit and choose a new peer
                servicesList.listAdapter.getItems().remove(lastVisit);
                //discoverService(); // SCAN
                process();
            }
        }

        if (getScan() != null) {

            if ((getScan().getScanIni() + scanTimeout) < System.currentTimeMillis()) {
                getScan().setScanEnd(System.currentTimeMillis());

                ArrayList<String> peersList = new ArrayList();
                for (WiFiP2pService peer : getServicesList().listAdapter.getItems()) {
                    String sub = peer.device.deviceName.substring(peer.device.deviceName.lastIndexOf('_') + 1);
                    peersList.add(sub);
                }
                getScan().setPeers(peersList);
                PTPLog.d(TAG, "PEERS:  " + getScan().getPeers().toString());

                getScan().setScanDur();
                PTPLog.d(TAG, "STORING:  " + "ID- " + getScan().getId());
                getScans().add(scan);
                addScan(scan); //DATABASE

                PTPLog.d(TAG, "SCAN INI: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanIni()) + "\n" +
                        "SCAN END: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanEnd()) + "\n" +
                        "SCAN DUR: " + "ID- " + getScan().getId() + " - " + sdf.format(getScan().getScanDur()));

                setScan(null);
                discoverService();
            }
        }

    }

    @Override
    public void connectP2p(WiFiP2pService service) {
        WifiP2pConfig config = new WifiP2pConfig();
        config.deviceAddress = service.device.deviceAddress;
        config.wps.setup = WpsInfo.PBC;
        if (serviceRequest != null)
            manager.removeServiceRequest(channel, serviceRequest,
                    new ActionListener() {

                        @Override
                        public void onSuccess() {
                            Log.d(TAG, "on Success remove Service Request");

                        }

                        @Override
                        public void onFailure(int arg0) {
                            Log.d(TAG, "on Failure remove Service Request");

                        }
                    });


        Log.d(TAG, "Connect() function ");

        manager.connect(channel, config, new ActionListener() {
            @Override
            public void onSuccess() {
                appendStatus("Connecting to service");
                Log.d(TAG, "Connection Attempt Successful ");

            }

            @Override
            public void onFailure(int errorCode) {
                appendStatus("Failed connecting to service");
                //Log.d(TAG, "Connection Attempt Failed " + info.getConnectionFailed());
                // it didn't connect

                if (getCurrentCon() != null) {

                    getCurrentCon().setFailure(System.currentTimeMillis());
                    getCurrentCon().setFailed(true);

                    Log.d(TAG, "CON FAILURE " + errorCode);
                    getConnections().add(getCurrentCon());
                    addConnection(getCurrentCon()); //DATABASE


                    setCurrentCon(null);
                }

                discoverService();
                getFragmentManager().beginTransaction().replace(R.id.container_root, servicesList, "services").commit();
            }
        });

    }

    public void sendUIDs() {
        ArrayList<UUID> arrayUids = new ArrayList();
        if (chatFragment.getChatManager() != null && !getMessagesDB().isEmpty()) {
            for (MessageRow message : getMessagesDB()) {
                arrayUids.add(message.getUuid());
            }

            int arrayLen = arrayUids.toString().getBytes().length;
            int labelLen = String.valueOf("uids list").length();
            int fullLen = arrayLen + String.valueOf(arrayLen).length() + labelLen;
            String send = "uids list" + String.valueOf(fullLen) + arrayUids;

            PTPLog.d(TAG, "Sending UIDS to peer: " + send.length() + " " + send);

            chatFragment.getChatManager().write(send.getBytes());
        }
    }

    public void sendDB(ArrayList<UUID> uidList) {

        if (uidList.isEmpty()) {
            PTPLog.d(TAG, "EMPTY LIST: ");
            String fullJson = "EMPTY";
            PTPLog.d(TAG, "Sending DB to peer: " + fullJson.getBytes().length + " " + fullJson);
            chatFragment.getChatManager().write(fullJson.getBytes());
        } else if (chatFragment.getChatManager() != null && !getMessagesDB().isEmpty()) {
            String fullJson = "";
            for (MessageRow message : getMessagesDB()) {
                if (uidList.contains(message.getUuid())) {
                    String jsonMsg = shiftInsertMessage(message);
                    fullJson = fullJson + jsonMsg;
                }
            }

            int jsonLen = fullJson.getBytes().length;
            int fullLen = jsonLen + String.valueOf(jsonLen).length();
            fullJson = String.valueOf(fullLen) + fullJson;

            PTPLog.d(TAG, "Sending DB to peer: " + fullJson.getBytes().length + " " + fullJson);
            chatFragment.getChatManager().write(fullJson.getBytes());

        }

    }

    public static SQLiteDatabase getmDatabase() {
        return mDatabase;
    }

    public ArrayList<Scan> getScans() {
        return scans;
    }

    public ArrayList<Connection> getConnections() {
        return connections;
    }

    public boolean isSendDB() {
        return sendDB;
    }

    public void setSendDB(boolean sendDB) {
        this.sendDB = sendDB;
    }

    public boolean isReceived() {
        return received;
    }

    public void setReceived(boolean received) {
        this.received = received;
    }

    @RequiresApi(api = Build.VERSION_CODES.KITKAT)
    @Override
    public boolean handleMessage(Message msg) {
        ArrayList<UUID> uidList;

        switch (msg.what) {
            case MESSAGE_READ:
                byte[] readBuf = (byte[]) msg.obj;
                // construct a string from the valid bytes in the buffer
                String readMessage = new String(readBuf, 0, msg.arg1);
                Log.d(TAG, "Message received: " + readMessage.getBytes().length + " - " + readMessage);

                if (readMessage.startsWith("EMPTY")) {
                    received = true;
                    Log.d(TAG, "EMPTY LIST RECEIVED");
                }

                if (readMessage.startsWith("uids list")) {
                    Log.d(TAG, "RECEIVING UIDS ");
                    uidList = checkUIDSinDB(readMessage);
                    Log.d(TAG, "SENDING MY DB");
                    sendDB(uidList);
                    sendDB = true;

                } else {
                    Log.d(TAG, "RECEIVING MESSAGES " + readMessage.equals("1") + "--" + readMessage.equals("EMPTY"));
                    if (!readMessage.equals("1") && !readMessage.equals("EMPTY")) {
                        composeMessage(readMessage);
                    }
                    received = true;
                }
                break;

            case MY_HANDLE:
                Log.d(TAG, "SENDING UIDS ");
                Object obj = msg.obj;
                (chatFragment).setChatManager((ChatManager) obj);
                if (firstTime = true) {
                    sendUIDs();
                    firstTime = false;
                }
        }
        return true;
    }


    public ArrayList<UUID> checkUIDSinDB(String fullMessage) {
        Log.d(TAG, "my db" + getMessagesDB().toString());

        ArrayList<UUID> uidsList = new ArrayList<UUID>();
        ArrayList<UUID> uidsListtoSend = new ArrayList<UUID>();

        fullMessage = fullMessage.substring(fullMessage.indexOf('[') + 1, fullMessage.indexOf(']'));
        StringTokenizer tokens = new StringTokenizer(fullMessage, ", ");

        while (tokens.hasMoreTokens()) {
            UUID next = UUID.fromString(tokens.nextToken());
            if (next != null) {
                uidsList.add(next);
                Log.d(TAG, "adding uids to received list " + next);

            }
        }
        for (MessageRow messageRow : getMessagesDB()) {
            if (!uidsList.contains(messageRow.getUuid())) {
                uidsListtoSend.add(messageRow.getUuid());
                Log.d(TAG, "peer is missing this id from my db" + messageRow.getUuid());
            }
        }
        return uidsListtoSend;
    }

    public void composeMessage(String fullMessage) {
        fullMessage = fullMessage.substring(fullMessage.indexOf('{'));
        Log.d(TAG, "Entering COMPOSE: " + fullMessage.getBytes().length + " - " + fullMessage);

        // Added to use when receiving more than one message
        StringTokenizer tokens = new StringTokenizer(fullMessage, "}");

        while (tokens.hasMoreTokens()) {
            String next = tokens.nextToken();
            if (next != null) {
                MessageRow row = MessageRow.parseMessageRow(next + "}");
                String myName = getMyDevice().deviceName;

                String sub = myName.substring(myName.lastIndexOf('_') + 1);
                String time = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(new Date());

                String newPath = row.getPath() + " --> " + sub + "-at-" + time;
                row.setPath(newPath);

                // now first add to app json array
                String json = shiftInsertMessage(row);

                if (getMessage(row.getUuid()) == null) {
                    addMessage(row);
                    //(chatFragment).pushMessage("Buddy: " + json);
                    ////// Add the message information ALSO to the connection attached /////
                    if (currentCon != null) {
                        currentCon.addMessage(row);
                    }
                }
                //currentCon.addMessage(row);

            }
        }
        superString = "";
    }

    @Override
    public void onResume() {
        super.onResume();
        receiver = new WiFiDirectBroadcastReceiver(manager, channel, this);
        registerReceiver(receiver, intentFilter);

        if (mApiClient.isConnected()) {
            startLocationUpdates();
        }
    }

    @Override
    public void onPause() {
        super.onPause();
        unregisterReceiver(receiver);

        if (mApiClient.isConnected()) {
            stopLocationUpdates();
        }
    }

    protected void stopLocationUpdates() {
        LocationServices.FusedLocationApi.removeLocationUpdates(
                mApiClient, this);
    }

    public void disconnect() {
        if (manager != null && channel != null) {

            manager.removeGroup(channel, new ActionListener() {
                @Override
                public void onSuccess() {
                    Log.d(TAG, "removeGroup onSuccess");
                    getCurrentCon().setConEnd(System.currentTimeMillis());
                    PTPLog.d(TAG, "CON END: " + sdf.format(new Date(getCurrentCon().getConEnd())));
                    getConnections().add(getCurrentCon());
                    addConnection(getCurrentCon()); //DATABASE
                    setCurrentCon(null);
                    setSendDB(false);
                    setReceived(false);
                    getFragmentManager().beginTransaction().replace(R.id.container_root, getServicesList(), "services").commit();
                    getStatusTxtView().setText("");
                    getStatusTxtView().setVisibility(View.VISIBLE);
                }

                @Override
                public void onFailure(int reason) {
                    Log.d(TAG, "removeGroup  onFailure " + reason);
//                    getCurrentCon().setConEnd(System.currentTimeMillis());
//                    PTPLog.d(TAG, "CON END: " + sdf.format(new Date(getCurrentCon().getConEnd())));
//                    getConnections().add(getCurrentCon());
//                    addConnection(getCurrentCon()); //DATABASE
                    setCurrentCon(null);
                    setSendDB(false);
                    setReceived(false);
                    getFragmentManager().beginTransaction().replace(R.id.container_root, getServicesList(), "services").commit();
                    getStatusTxtView().setText("");
                    getStatusTxtView().setVisibility(View.VISIBLE);
                }
            });
        }
    }


    @Override
    public void onConnectionInfoAvailable(WifiP2pInfo p2pInfo) {
        Thread handler = null;
        /*
         * The group owner accepts connections using a server socket and then spawns a
         * client socket for every client. This is handled by {@code
         * GroupOwnerSocketHandler}
         */

        Log.d(TAG, "group owner address: " + p2pInfo.groupOwnerAddress);

        if (p2pInfo.isGroupOwner && getCurrentCon() != null) {
            Log.d(TAG, "Connected as group owner");
            getCurrentCon().setGroupOwner(true);

            try {
                handler = new GroupOwnerSocketHandler(
                        ((MessageTarget) this).getHandler());
                handler.start();
            } catch (IOException e) {
                Log.d(TAG,
                        "Failed to create a server thread - " + e.getMessage());
                return;
            }
        } else {
            Log.d(TAG, "Connected as peer");
            if (getCurrentCon() != null) {
                getCurrentCon().setGroupOwner(false);
                Log.d(TAG, String.valueOf(getCurrentCon().isGroupOwner()));
            }
            handler = new ClientSocketHandler(
                    ((MessageTarget) this).getHandler(),
                    p2pInfo.groupOwnerAddress);
            handler.start();
        }

        chatFragment = new WiFiChatFragment();
        getFragmentManager().beginTransaction().replace(R.id.container_root, chatFragment).commit();
        statusTxtView.setVisibility(View.GONE);


    }

    public WiFiDirectServicesList getServicesList() {
        return servicesList;
    }

    public void appendStatus(String status) {
        String current = statusTxtView.getText().toString();
        statusTxtView.setText(current + "\n" + status);

    }

    public TextView getStatusTxtView() {
        return statusTxtView;
    }

    //show device info on screen
    public void updateThisDevice(WifiP2pDevice device) {

        TextView view = (TextView) findViewById(R.id.mystatus);
        if (view != null) {
            view.setText("My Name: " + device.deviceName + "\n My Address: " + device.deviceAddress + "\n My Status: " + device.status);
            myDevice = device;
        }
        return;
    }

    @Override
    public void onBackPressed() {
        manager = (WifiP2pManager) getSystemService(Context.WIFI_P2P_SERVICE);
        channel = manager.initialize(mContext, getMainLooper(), null);

        //startRegistrationAndDiscovery();
        //servicesList = new WiFiDirectServicesList();
        getFragmentManager().beginTransaction().replace(R.id.container_root, servicesList, "services").commit();
        discoverService();
    }

    public static WifiP2pDevice getMyDevice() {
        return myDevice;
    }


    ////////////////////////////////// added ddbb and ptplog/////////////////////////////////////////////

    public void deleteExpiredMessages() {
        for (MessageRow row : getMessagesDB()) {
            Date currentDate = new Date();
            String curDa = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").format(currentDate);
            Date ttlTime = null;

            try {
                currentDate = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").parse(curDa);
                ttlTime = new SimpleDateFormat("MM/dd/yyyy HH:mm:ss").parse(row.getTtl());
            } catch (ParseException e) {
                e.printStackTrace();
            }

            if (currentDate.after(ttlTime)) {
                removeMessage(row);
            }
        }
    }

    public void removeAllMessages() {
//        for (MessageRow row : getMessagesDB()) {
//            removeMessage(row);
//        }

        mDatabase.execSQL("delete from " + MessageDbSchema.MessageTable.NAME);
        mDatabase.execSQL("delete from " + MessageDbSchema.ConnectionTable.NAME);
        mDatabase.execSQL("delete from " + MessageDbSchema.ScanTable.NAME);
        mDatabase.execSQL("delete from " + MessageDbSchema.GeoTable.NAME);
        mDatabase.execSQL("delete from " + MessageDbSchema.BatteryTable.NAME);

    }


    public static ContentValues getContentValues(MessageRow message) {
        ContentValues values = new ContentValues();
        values.put(MessageDbSchema.MessageTable.Cols.UUID, message.getUuid().toString());
        values.put(MessageDbSchema.MessageTable.Cols.MSG, message.getMsg());
        values.put(MessageDbSchema.MessageTable.Cols.SENDER, message.getSender());
        values.put(MessageDbSchema.MessageTable.Cols.TIME, message.getTime());
        values.put(MessageDbSchema.MessageTable.Cols.TTL, message.getTtl());
        values.put(MessageDbSchema.MessageTable.Cols.PATH, message.getPath());

        return values;
    }

    public static ContentValues getContentValues(Scan scan) {
        ContentValues values = new ContentValues();
        values.put(MessageDbSchema.ScanTable.Cols.ID, scan.getId());
        values.put(MessageDbSchema.ScanTable.Cols.SCAN_INIT, scan.getScanIni());
        values.put(MessageDbSchema.ScanTable.Cols.SCAN_END, scan.getScanEnd());
        values.put(MessageDbSchema.ScanTable.Cols.SCAN_DURATION, scan.getScanDur());
        values.put(MessageDbSchema.ScanTable.Cols.PEERS, scan.peersToJSON().toString());

        return values;
    }

    public static ContentValues getContentValues(Connection connection) {
        ContentValues values = new ContentValues();
        values.put(MessageDbSchema.ConnectionTable.Cols.ID, connection.getId());
        values.put(MessageDbSchema.ConnectionTable.Cols.GO, connection.isGroupOwner());
        values.put(MessageDbSchema.ConnectionTable.Cols.INITIATOR, connection.isInitiator());
        values.put(MessageDbSchema.ConnectionTable.Cols.FAILED, connection.isFailed());
        values.put(MessageDbSchema.ConnectionTable.Cols.FAILURE, connection.getFailure());
        values.put(MessageDbSchema.ConnectionTable.Cols.CONNECTED_PEER, connection.getConnectedPeer());
        values.put(MessageDbSchema.ConnectionTable.Cols.CONNECTING, connection.getConnecting());
        values.put(MessageDbSchema.ConnectionTable.Cols.CONNECTION_INIT, connection.getConIni());
        values.put(MessageDbSchema.ConnectionTable.Cols.DISCONNECTING, connection.getDisconnecting());
        values.put(MessageDbSchema.ConnectionTable.Cols.CONNECTION_END, connection.getConEnd());

        ArrayList<String> ids = new ArrayList<>();
        for (MessageRow mes : connection.getMessages()) {
            ids.add(mes.getUuid().toString());
        }
        values.put(MessageDbSchema.ConnectionTable.Cols.CONNECTION_MESSAGES, ids.toString());

        return values;
    }

    public static ContentValues getContentValues(GeoEvent geo) {
        ContentValues values = new ContentValues();
        values.put(MessageDbSchema.GeoTable.Cols.ACTION, String.valueOf(geo.getAction()));
        values.put(MessageDbSchema.GeoTable.Cols.TIME, String.valueOf(geo.getTime()));

        return values;
    }

    public static ContentValues getContentValues(BatteryEvent bat) {
        ContentValues values = new ContentValues();
        values.put(MessageDbSchema.BatteryTable.Cols.PERCENTAGE, String.valueOf(bat.getPercentage()));
        values.put(MessageDbSchema.BatteryTable.Cols.TIME, String.valueOf(bat.getTime()));

        return values;
    }

    private MessageCursorWrapper queryMessages(String whereClause, String[] whereArgs) {
        Cursor cursor = mDatabase.query(
                MessageDbSchema.MessageTable.NAME,
                null,
                whereClause,
                whereArgs,
                null,
                null,
                null);
        return new MessageCursorWrapper(cursor);
    }

    private MessageCursorWrapper queryConnections(String whereClause, String[] whereArgs) {
        Cursor cursor = mDatabase.query(
                MessageDbSchema.ConnectionTable.NAME,
                null,
                whereClause,
                whereArgs,
                null,
                null,
                null);
        return new MessageCursorWrapper(cursor);
    }

    private MessageCursorWrapper queryScans(String whereClause, String[] whereArgs) {
        Cursor cursor = mDatabase.query(
                MessageDbSchema.ScanTable.NAME,
                null,
                whereClause,
                whereArgs,
                null,
                null,
                null);
        return new MessageCursorWrapper(cursor);
    }

    private MessageCursorWrapper queryGeo(String whereClause, String[] whereArgs) {
        Cursor cursor = mDatabase.query(
                MessageDbSchema.GeoTable.NAME,
                null,
                whereClause,
                whereArgs,
                null,
                null,
                null);
        return new MessageCursorWrapper(cursor);
    }

    private MessageCursorWrapper queryBat(String whereClause, String[] whereArgs) {
        Cursor cursor = mDatabase.query(
                MessageDbSchema.BatteryTable.NAME,
                null,
                whereClause,
                whereArgs,
                null,
                null,
                null);
        return new MessageCursorWrapper(cursor);
    }

    public String shiftInsertMessage(MessageRow row) {
        JSONObject jsonobj = MessageRow.getAsJSONObject(row);
        if (jsonobj != null) {
            mMessageArray.put(jsonobj);
        }
        //mMessageArray = JSONUtils.truncateJSONArray(mMessageArray, 10);  // truncate the oldest 10.
        return jsonobj.toString();
    }


    public ArrayList<MessageRow> getMessagesDB() {
        ArrayList<MessageRow> messages = new ArrayList<MessageRow>();

        MessageCursorWrapper cursor = queryMessages(null, null);

        try {
            cursor.moveToFirst();
            while (!cursor.isAfterLast()) {
                messages.add(cursor.getMessage());
                cursor.moveToNext();
            }
        } finally {
            cursor.close();
        }

        PTPLog.d(TAG, "MESSAGES : " + messages.size());

        return messages;
    }

    public ArrayList<Connection> getConnectionsDB() {
        ArrayList<Connection> connections = new ArrayList<Connection>();

        MessageCursorWrapper cursor = queryConnections(null, null);

        try {
            cursor.moveToFirst();
            while (!cursor.isAfterLast()) {
                connections.add(cursor.getConnection());
                cursor.moveToNext();
            }
        } finally {
            cursor.close();
        }

        return connections;
    }

    public ArrayList<Scan> getScansDB() {
        ArrayList<Scan> scans = new ArrayList<Scan>();

        MessageCursorWrapper cursor = queryScans(null, null);

        try {
            cursor.moveToFirst();
            while (!cursor.isAfterLast()) {
                scans.add(cursor.getScan());
                cursor.moveToNext();
            }
        } finally {
            cursor.close();
        }

        return scans;
    }


    public ArrayList<GeoEvent> getGeoDB() {
        ArrayList<GeoEvent> geoEvents = new ArrayList<GeoEvent>();

        MessageCursorWrapper cursor = queryGeo(null, null);

        try {
            cursor.moveToFirst();
            while (!cursor.isAfterLast()) {
                geoEvents.add(cursor.getGeo());
                cursor.moveToNext();
            }
        } finally {
            cursor.close();
        }

        return geoEvents;
    }

    public ArrayList<BatteryEvent> getBatDB() {
        ArrayList<BatteryEvent> batEvents = new ArrayList<BatteryEvent>();

        MessageCursorWrapper cursor = queryBat(null, null);

        try {
            cursor.moveToFirst();
            while (!cursor.isAfterLast()) {
                batEvents.add(cursor.getBattery());
                cursor.moveToNext();
            }
        } finally {
            cursor.close();
        }

        return batEvents;
    }

    public MessageRow getMessage(UUID uuid) {
        MessageCursorWrapper cursor = queryMessages(
                MessageDbSchema.MessageTable.Cols.UUID + " = ?",
                new String[]{uuid.toString()}
        );

        try {
            if (cursor.getCount() == 0) {
                return null;
            }

            cursor.moveToFirst();
            return cursor.getMessage();
        } finally {
            cursor.close();
        }
    }

    public void addMessage(MessageRow msg) {
        if (getMessage(msg.getUuid()) == null) {
            ContentValues values = getContentValues(msg);
            mDatabase.insert(MessageDbSchema.MessageTable.NAME, null, values);
            PTPLog.d(TAG, "Adding message to the db: " + msg);
        }

    }

    public void addScan(Scan scan) {
        ContentValues values = getContentValues(scan);
        PTPLog.d(TAG, "VALUEEEES " + values);
        mDatabase.insert(MessageDbSchema.ScanTable.NAME, null, values);
        PTPLog.d(TAG, "Adding scan to the db: " + scan.getPeers());
    }


    public void addConnection(Connection connection) {
        ContentValues values = getContentValues(connection);
        mDatabase.insert(MessageDbSchema.ConnectionTable.NAME, null, values);
        PTPLog.d(TAG, "Adding connection to the db: " + connection);
    }


    public static void addGeoEvent(GeoEvent geoEvent) {
        ContentValues values = getContentValues(geoEvent);
        mDatabase.insert(MessageDbSchema.GeoTable.NAME, null, values);
        PTPLog.d(TAG, "Adding geoEvent to the db: --? ");
    }

    public void addBatteryEvent(BatteryEvent batteryEvent) {
        ContentValues values = getContentValues(batteryEvent);
        mDatabase.insert(MessageDbSchema.BatteryTable.NAME, null, values);
        PTPLog.d(TAG, "Adding batteryEvent to the db: --? ");
    }

    public void removeMessage(MessageRow msg) {
        String uid = msg.getUuid().toString();
        mDatabase.delete(MessageDbSchema.MessageTable.NAME, "UUID = ?", new String[]{uid});

    }


    @Override
    public void onStart() {
        super.onStart();
        client.connect();

        mApiClient.connect();
        // ATTENTION: This was auto-generated to implement the App Indexing API.
        // See https://g.co/AppIndexing/AndroidStudio for more information.


        Action viewAction = Action.newAction(
                Action.TYPE_VIEW, // TODO: choose an action type.
                "WiFiServiceDiscovery Page", // TODO: Define a title for the content shown.
                // TODO: If you have web page content that matches this app activity's content,
                // make sure this auto-generated web page URL is correct.
                // Otherwise, set the URL to null.
                Uri.parse("http://host/path"),
                // TODO: Make sure this auto-generated app URL is correct.
                Uri.parse("android-app://com.example.android.wifidirect.discovery/http/host/path")
        );
        AppIndex.AppIndexApi.start(client, viewAction);


    }


    public WiFiChatFragment getChatFragment() {
        return chatFragment;
    }

    public Scan getScan() {
        return scan;
    }

    public void setScan(Scan scan) {
        this.scan = scan;
    }

    public Connection getCurrentCon() {
        return currentCon;
    }

    public static String getTAG() {
        return TAG;
    }


    public void setCurrentCon(Connection currentCon) {
        this.currentCon = currentCon;
    }

//    public WifiP2pDevice getConnectedPeer() {
//        for(WifiP2pDevice d : mPeers ){
//            PTPLog.d(TAG, "getConnectedPeer : device : " + d.deviceName + " status: " + WiFiDirectServicesList.getDeviceStatus(d.status));
//            if( d.status == WifiP2pDevice.CONNECTED){
//                peer = d;
//                if(getCurrentCon() !=null) {
//                    getCurrentCon().setConnectedPeer(peer.deviceName);
//                    PTPLog.d(TAG, "CONNECTED PEER IN GET CONNECTED PEER: " + getCurrentCon().getConnectedPeer());
//                }
//            }
//        }
//        return peer;
//}

    public void setConnectedPeer(WifiP2pDevice peer) {
        this.peer = peer;
    }

    public int getLevel() {
        return level;
    }

//    public ArrayList<Connection> getConnections() {
//        return connections;
//    }

//    public ArrayList<Scan> getScans() {
//        return scans;
//    }

    ////////////////////////////////// method to send server info ///////////////////////////////////////
    public void createServerInfoFile() {
        String myName = getMyDevice().deviceName;

        String sub = myName.substring(myName.lastIndexOf('_') + 1);

        ServerInfo serverinfo = new ServerInfo(sub, getConnectionsDB(), getScansDB(), getMessagesDB(), getBatDB(), getGeoDB());

        PTPLog.d(TAG, "GEOFENCING EVENTS" + getGeoDB());

        String strJson = serverinfo.toJSON();

        int num = fileNumber++;

        try {
            File root = new File(Environment.getExternalStorageDirectory(), "AppLogs");
            if (!root.exists()) {
                root.mkdirs();
            }
            File file = new File(root, "Log" + 0);
            FileWriter writer = new FileWriter(file);
            writer.append(strJson);
            writer.flush();
            writer.close();
            //Toast.makeText(this, "Saved", Toast.LENGTH_SHORT).show();
            PTPLog.d(TAG, "FILE CREATED " + file.getName());


        } catch (IOException e) {
            e.printStackTrace();
        }


    }


    public static class PTPLog {
        public static void i(String tag, String msg) {
            Log.i(tag, msg);
        }

        public static void d(String tag, String msg) {
            Log.d(tag, msg);
        }

        public static void e(String tag, String msg) {
            Log.e(tag, msg);
        }
    }


}
